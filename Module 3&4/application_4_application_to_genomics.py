"""
Provide code and solution for Application 4
"""
import urllib2
import random

import matplotlib.pyplot as plt
import project4_computing_alignments_of_sequences as student
    

# URLs for data files
PAM50_URL = "http://storage.googleapis.com/codeskulptor-alg/alg_PAM50.txt"
HUMAN_EYELESS_URL = "http://storage.googleapis.com/codeskulptor-alg/alg_HumanEyelessProtein.txt"
FRUITFLY_EYELESS_URL = "http://storage.googleapis.com/codeskulptor-alg/alg_FruitflyEyelessProtein.txt"
CONSENSUS_PAX_URL = "http://storage.googleapis.com/codeskulptor-alg/alg_ConsensusPAXDomain.txt"
WORD_LIST_URL = "http://storage.googleapis.com/codeskulptor-assets/assets_scrabble_words3.txt"



###############################################
# provided code

def read_scoring_matrix(filename):
    """
    Read a scoring matrix from the file named filename.  

    Argument:
    filename -- name of file containing a scoring matrix

    Returns:
    A dictionary of dictionaries mapping X and Y characters to scores
    """
    scoring_dict = {}
    scoring_file = urllib2.urlopen(filename)
    ykeys = scoring_file.readline()
    ykeychars = ykeys.split()
    for line in scoring_file.readlines():
        vals = line.split()
        xkey = vals.pop(0)
        scoring_dict[xkey] = {}
        for ykey, val in zip(ykeychars, vals):
            scoring_dict[xkey][ykey] = int(val)
    return scoring_dict


def read_protein(filename):
    """
    Read a protein sequence from the file named filename.

    Arguments:
    filename -- name of file containing a protein sequence

    Returns:
    A string representing the protein
    """
    protein_file = urllib2.urlopen(filename)
    protein_seq = protein_file.read()
    protein_seq = protein_seq.rstrip()
    return protein_seq


def read_words(filename):
    """
    Load word list from the file named filename.

    Returns a list of strings.
    """
    # load assets
    word_file = urllib2.urlopen(filename)
    
    # read in files as string
    words = word_file.read()
    
    # template lines and solution lines list of line string
    word_list = words.split('\n')
    print "Loaded a dictionary with", len(word_list), "words"
    return word_list

# let's process some data
seq_x = read_protein(HUMAN_EYELESS_URL)
seq_y = read_protein(FRUITFLY_EYELESS_URL)
sco_mat = read_scoring_matrix(PAM50_URL)
ali_mat = student.compute_alignment_matrix(seq_x, seq_y, sco_mat, False)
pax_dom = read_protein(CONSENSUS_PAX_URL)
spell_sm = student.build_scoring_matrix(set(['a', 'b', 'c', 'd', 'e',
        'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',
        't', 'u', 'v', 'w', 'x', 'y', 'z']), 2, 1, 0)
    
def question1():
    ans1 = student.compute_local_alignment(seq_x, seq_y, sco_mat, ali_mat)
    return ans1

print "Question 1: ", question1()

def question2():
    ans1 = question1()
    loc_hum = ""
    loc_fly = "" 
    for i in range(len(ans1[1])):
        if ans1[1][i] != '-':
            loc_hum += ans1[1][i]
        if ans1[2][i] != '-':
            loc_fly += ans1[2][i]
    
    ali_mat1 = student.compute_alignment_matrix(loc_hum, pax_dom, sco_mat, True)
    hum_vs_pax = student.compute_global_alignment(loc_hum, pax_dom, sco_mat, ali_mat1)
    
    ali_mat2 = student.compute_alignment_matrix(loc_fly, pax_dom, sco_mat, True)
    fly_vs_pax = student.compute_global_alignment(loc_fly, pax_dom, sco_mat, ali_mat2)
    
    count_h = 0
    count_f = 0
    
    length = len(hum_vs_pax[1])
    for j in range(len(hum_vs_pax[1])):
        if hum_vs_pax[1][j] == hum_vs_pax[2][j]:
            count_h += 1
        if fly_vs_pax[1][j] == fly_vs_pax[2][j]:
            count_f += 1
    
    return 100*count_h / float(length), 100*count_f / float(length)
              
print "Question 2: ", question2()  

def generate_null_distribution(seq_x, seq_y, sco_mat, num_tri):
    """
    takes as input two sequences seq_x and seq_y, a scoring matrix sco_mat,
    and a number of trials num_tri. This function should return a dictionary 
    sco_dist that represents an un-normalized distribution generated by 
    performing the following process num_tri times:
    
    * Generate a random permutation rand_y of the sequence seq_y using 
    random.shuffle().
    * Compute the maximum value score for the local alignment of seq_x and 
    rand_y using the score matrix sco_mat.
    * Increment the entry score in the dictionary scoring_distribution by one.
    """
    score_dist = {}
    rand_y = list(seq_y)
    for i in range(num_tri):
        random.shuffle(rand_y)
        ali_mat3 = student.compute_alignment_matrix(seq_x, rand_y, sco_mat, False)
        score = student.compute_local_alignment(seq_x, rand_y, sco_mat, ali_mat3)[0]
        if score_dist.has_key(score):
            score_dist[score] += 1
        else:
            score_dist[score] = 1
    return score_dist

num_trials = 1000

def question4():
    distribution = generate_null_distribution(seq_x, seq_y, sco_mat, num_trials)
    X = []
    Y = []
    for key in distribution.keys():
        X.append(key)
        Y.append(float(distribution[key]) / num_trials)

    plt.bar(X, Y, width = 1, color="blue")

    fig = plt.gcf()
    fig.suptitle('Normalized distribution', fontsize=13)
    ax = fig.add_subplot(111)
    ax.set_xlabel('Scores', fontsize = 12)
    ax.set_ylabel('Fraction of total trials', fontsize = 12)
    fig.set_size_inches(8, 8)
    fig.savefig('null_distribution.png', dpi=75)
    plt.show()
    return distribution
    
distribution = question4()
print "Question 4: ", distribution

def question5():
    # calculate the mean
    scores_mean = 0
    for key in distribution.keys():
        scores_mean += distribution[key]*key
    scores_mean = float(scores_mean) / num_trials
    # calculate standard deviation
    std_dev = 0
    for key in distribution.keys():
        std_dev += distribution[key]*(key - scores_mean)**2
    std_dev = (std_dev / num_trials)**0.5
    z_score = (question1()[0] - scores_mean) / std_dev
    
    return scores_mean, std_dev, z_score
    
print "Question 5: ", question5()

def question7():
    seq1 = 'kitten'
    seq2 = 'sitting'
    spell_am = student.compute_alignment_matrix(seq1, seq2, spell_sm, True)
    score = student.compute_global_alignment(seq1, seq2, spell_sm, spell_am )
    return len(seq1) + len(seq2) - score[0]

print "Question 7: ", question7()

def check_spelling(checked_word, dist, word_list):
    ans = []
    for word in word_list:
        spell_am = student.compute_alignment_matrix(word, checked_word, spell_sm, True)
        score = student.compute_global_alignment(word, checked_word, spell_sm, spell_am)
        edit_distance = len(word) + len(checked_word) - score[0]
        if edit_distance <= dist:
            ans.append(word)
    return set(ans)
        

def question8():
    word_list = read_words(WORD_LIST_URL)
    return check_spelling('humble', 1, word_list), check_spelling('firefly', 2, word_list)
    
print "Question 8: ", question8()
    
    
    
        

        
        
    
    
    
    
              

        

            
            
    
            

        

